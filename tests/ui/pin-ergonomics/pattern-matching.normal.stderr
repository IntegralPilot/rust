error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:35:9
   |
LL |     let Foo { x, y } = foo_mut;
   |         ^^^^^^^^^^^^   ------- this expression has type `Pin<&mut Foo<T, U>>`
   |         |
   |         expected `Pin<&mut Foo<T, U>>`, found `Foo<_, _>`
   |
   = note: expected struct `Pin<&mut Foo<T, U>>`
              found struct `Foo<_, _>`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |     let Foo { x, y } = *foo_mut;
   |                        +

error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:40:9
   |
LL |     let Foo { x, y } = foo_const;
   |         ^^^^^^^^^^^^   --------- this expression has type `Pin<&Foo<T, U>>`
   |         |
   |         expected `Pin<&Foo<T, U>>`, found `Foo<_, _>`
   |
   = note: expected struct `Pin<&Foo<T, U>>`
              found struct `Foo<_, _>`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |     let Foo { x, y } = *foo_const;
   |                        +

error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:48:9
   |
LL |     match bar_mut {
   |           ------- this expression has type `Pin<&mut Bar<T, U>>`
LL |         Bar::Foo(x, y) => {
   |         ^^^^^^^^^^^^^^ expected `Pin<&mut Bar<T, U>>`, found `Bar<_, _>`
   |
   = note: expected struct `Pin<&mut Bar<T, U>>`
                found enum `Bar<_, _>`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |     match *bar_mut {
   |           +

error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:53:18
   |
LL |         _ if let Bar::Bar { x, y } = bar_mut => {
   |                  ^^^^^^^^^^^^^^^^^   ------- this expression has type `Pin<&mut Bar<T, U>>`
   |                  |
   |                  expected `Pin<&mut Bar<T, U>>`, found `Bar<_, _>`
   |
   = note: expected struct `Pin<&mut Bar<T, U>>`
                found enum `Bar<_, _>`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |         _ if let Bar::Bar { x, y } = *bar_mut => {
   |                                      +

error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:61:9
   |
LL |     match bar_const {
   |           --------- this expression has type `Pin<&Bar<T, U>>`
LL |         Bar::Bar { x, y } => {
   |         ^^^^^^^^^^^^^^^^^ expected `Pin<&Bar<T, U>>`, found `Bar<_, _>`
   |
   = note: expected struct `Pin<&Bar<T, U>>`
                found enum `Bar<_, _>`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |     match *bar_const {
   |           +

error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:66:18
   |
LL |         _ if let Bar::Foo(x, y) = bar_const => {
   |                  ^^^^^^^^^^^^^^   --------- this expression has type `Pin<&Bar<T, U>>`
   |                  |
   |                  expected `Pin<&Bar<T, U>>`, found `Bar<_, _>`
   |
   = note: expected struct `Pin<&Bar<T, U>>`
                found enum `Bar<_, _>`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |         _ if let Bar::Foo(x, y) = *bar_const => {
   |                                   +

error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:76:9
   |
LL |     let (Foo { x, y },) = foo_mut;
   |         ^^^^^^^^^^^^^^^   ------- this expression has type `Pin<&mut (Foo<T, U>,)>`
   |         |
   |         expected `Pin<&mut (Foo<T, U>,)>`, found `(_,)`
   |
   = note: expected struct `Pin<&mut (Foo<T, U>,)>`
               found tuple `(_,)`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |     let (Foo { x, y },) = *foo_mut;
   |                           +

error[E0308]: mismatched types
  --> $DIR/pattern-matching.rs:80:9
   |
LL |     let (Foo { x, y },) = foo_const;
   |         ^^^^^^^^^^^^^^^   --------- this expression has type `Pin<&(Foo<T, U>,)>`
   |         |
   |         expected `Pin<&(Foo<T, U>,)>`, found `(_,)`
   |
   = note: expected struct `Pin<&(Foo<T, U>,)>`
               found tuple `(_,)`
help: consider dereferencing to access the inner value using the Deref trait
   |
LL |     let (Foo { x, y },) = *foo_const;
   |                           +

error[E0529]: expected an array or slice, found `Pin<&mut [Foo<T, U>; 1]>`
  --> $DIR/pattern-matching.rs:87:9
   |
LL |     let [Foo { x, y }] = foo_mut;
   |         ^^^^^^^^^^^^^^ pattern cannot match with input type `Pin<&mut [Foo<T, U>; 1]>`

error[E0529]: expected an array or slice, found `Pin<&[Foo<T, U>; 1]>`
  --> $DIR/pattern-matching.rs:91:9
   |
LL |     let [Foo { x, y }] = foo_const;
   |         ^^^^^^^^^^^^^^ pattern cannot match with input type `Pin<&[Foo<T, U>; 1]>`

error[E0529]: expected an array or slice, found `Pin<&mut [Foo<T, U>]>`
  --> $DIR/pattern-matching.rs:98:12
   |
LL |     if let [Foo { x, y }] = foo_mut {
   |            ^^^^^^^^^^^^^^ pattern cannot match with input type `Pin<&mut [Foo<T, U>]>`

error[E0529]: expected an array or slice, found `Pin<&[Foo<T, U>]>`
  --> $DIR/pattern-matching.rs:103:12
   |
LL |     if let [Foo { x, y }] = foo_const {
   |            ^^^^^^^^^^^^^^ pattern cannot match with input type `Pin<&[Foo<T, U>]>`

error: aborting due to 12 previous errors

Some errors have detailed explanations: E0308, E0529.
For more information about an error, try `rustc --explain E0308`.
